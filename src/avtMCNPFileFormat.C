
// Copyright (c) Lawrence Livermore National Security, LLC and other VisIt
// Project developers.  See the top-level LICENSE file for dates and other
// details.  No copyright assignment is required to contribute to VisIt.

// ************************************************************************* //
//                            avtMCNPFileFormat.C                           //
// ************************************************************************* //

#include <avtMCNPFileFormat.h>

#include <string>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkPoints.h>

#include <vtkAppendPolyData.h>


#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>

#include <DebugStream.h>


#define MARK_LEN 32
#define _SIZE(arr) sizeof(arr) / sizeof(float)


using     std::string;
using     std::vector;
using     std::stringstream;

//globalne
vector<float> x;
vector<float> y;
vector<float> z;
vector<float> value;
vector<float> relErr;

ifstream infile;


// ****************************************************************************
//  Method: avtMCNPFileFormat constructor
//
//  Programmer: imenko_prezimenovic -- generated by xml2avt
//  Creation:   Wed Dec 28 11:06:59 PDT 2022
//
// ****************************************************************************

avtMCNPFileFormat::avtMCNPFileFormat(const char *fn)
    : avtSTSDFileFormat(fn)
{
    avtMCNPFileFormat::initialized = false;
    avtMCNPFileFormat::filename = fn;
}

void
avtMCNPFileFormat::ActivateTimestep(){
    Initialize();
}

void
avtMCNPFileFormat::Initialize(){
    if(!initialized){

        infile.open(
            avtMCNPFileFormat::filename
        );

        if (!infile)
        {
        EXCEPTION1(InvalidDBTypeException,
        "Nije moguÄ‡e otvoriti datoteku.");
        }
        initialized = true;
    }
}



// ****************************************************************************
//  Method: avtMCNPFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: imenko_prezimenovic -- generated by xml2avt
//  Creation:   Wed Dec 28 11:06:59 PDT 2022
//
// ****************************************************************************

avtMCNPFileFormat::~avtMCNPFileFormat()
{
    FreeUpResources();
}

void
avtMCNPFileFormat::FreeUpResources(void)
{
    infile.close();
    initialized = false;
}


// ****************************************************************************
//  Method: avtMCNPFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: imenko_prezimenovic -- generated by xml2avt
//  Creation:   Wed Dec 28 11:06:59 PDT 2022
//
// ****************************************************************************

void
avtMCNPFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
    // Initialize();
    string meshname = "MCNP mesh";
    
    
    avtMeshMetaData *mesh = new avtMeshMetaData;
    mesh->name = meshname;
    mesh->meshType = AVT_RECTILINEAR_MESH;
    md->Add(mesh);


    
    string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    string varname = "flux";
    AddScalarVarToMetaData(md, varname, mesh_for_this_var, AVT_ZONECENT);

    string varname2 = "relative error";
    AddScalarVarToMetaData(md, varname2, mesh_for_this_var, AVT_ZONECENT);

    
}


// ****************************************************************************
//  Method: avtMCNPFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: imenko_prezimenovic -- generated by xml2avt
//  Creation:   Wed Dec 28 11:06:59 PDT 2022
//
// ****************************************************************************

vtkDataSet *
avtMCNPFileFormat::GetMesh(const char *meshname)
{

    ReadData();

    int dims[3] = {1, 1, 1};
    vtkFloatArray *coords[3] = {0, 0, 0};

    dims[0] = x.size();
    dims[1] = y.size();
    dims[2] = z.size();
	for (int i = 0; i < 3; i++)
	{
		debug1 << "++++++++++++++++++++++++++++++++++++++++++++++++++++" << endl;
		debug1 << "[DIMENSIONS " << i << ":] " << i << ": " << dims[i] << endl;
		for (int j = 0; j < dims[i]; j++)
		{
			debug1 << x.at(i) << endl;
		}
		debug1 << "++++++++++++++++++++++++++++++++++++++++++++++++++++" << endl;
	}

    coords[0] = vtkFloatArray::New();
    coords[0]->SetNumberOfTuples(dims[0]);
    float *xarray = (float *)coords[0]->GetVoidPointer(0);
    for(int i = 0; i < dims[0]; i++)
        xarray[i] = x.at(i);

    coords[1] = vtkFloatArray::New();
    coords[1]->SetNumberOfTuples(dims[1]);
    float *yarray = (float *)coords[1]->GetVoidPointer(0);
    for(int i = 0; i < dims[1]; i++)
        yarray[i] = y.at(i);

    coords[2] = vtkFloatArray::New();
    coords[2]->SetNumberOfTuples(dims[2]);
    float *zarray = (float *)coords[2]->GetVoidPointer(0);
    for(int i = 0; i < dims[2]; i++)
        zarray[i] = z.at(i);

    vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New();
	rgrid->SetDimensions(dims);
    rgrid->SetXCoordinates(coords[0]);
    coords[0]->Delete();
    rgrid->SetYCoordinates(coords[1]);
    coords[1]->Delete();
    rgrid->SetZCoordinates(coords[2]);
    coords[2]->Delete();
    return rgrid;
}


// ****************************************************************************
//  Method: avtMCNPFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: imenko_prezimenovic -- generated by xml2avt
//  Creation:   Wed Dec 28 11:06:59 PDT 2022
//
// ****************************************************************************

vtkDataArray *
avtMCNPFileFormat::GetVar(const char *varname)
{
    int nvals = value.size();
    vtkFloatArray *arr = vtkFloatArray::New();
    arr->SetNumberOfTuples(nvals);
    float *data = (float *)arr->GetVoidPointer(0);
    for (int i = 0 ; i < nvals ; i++)
    {
        // if(i %10000 == 0)
        //     cout << relErr.at(i) << endl;

        // if(strcmp(varname, "flux") == 0)
        //     arr->SetTuple1(i, value.at(i));
        // else if(strcmp(varname, "relative error") == 0)
        //     arr->SetTuple1(i, relErr.at(i));

        if(strcmp(varname, "flux") == 0)
            data[i] = value.at(i);
        else if(strcmp(varname, "relative error") == 0)
            data[i] = relErr.at(i);

    }
    // cout << "--------------- array -------------------" << endl;
    // for (int i = 0; i < _SIZE(arr); i++)
    // {
    //     if(i % 1000 == 0)
    //         cout << data[i] << endl;
    // }
    
    // cout << "----------------------------------------------------------" << endl;
    
    return arr;
}


// ****************************************************************************
//  Method: avtMCNPFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: imenko_prezimenovic -- generated by xml2avt
//  Creation:   Wed Dec 28 11:06:59 PDT 2022
//
// ****************************************************************************

vtkDataArray *
avtMCNPFileFormat::GetVectorVar(const char *varname)
{
    //return 0;
     EXCEPTION1(InvalidVariableException, varname);
    

    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    // delete [] one_entry;
    // return rv;
    //
}

void ReadHeader();

void
avtMCNPFileFormat::ReadData(){
    ReadHeader();

    value.clear();
    relErr.clear();

    float tempValue, tempErr;
    char line[2048];

    // cout << "++++++++++++READING DATA++++++++++++++++++" << endl;
    // int i = 0;
    while(!infile.eof()){
        infile.getline(line, 2048);

        if(line[0] == 0)
            break;

        sscanf(line, "%*f %*f %*f %f %f", &tempValue, &tempErr);

        // if(i % 10000 == 0)
        //     cout << "val:" << tempValue << " err:" << tempErr << endl;
        // i++;

        value.push_back(tempValue);
        relErr.push_back(tempErr);
    }
    // cout << "+++++++++++++++++++++++++++++++++++++++++++" << endl;


}

string convertToString(char* a, int size)
{
    int i;
    string s = "";
    for (i = 0; i < size; i++) {
        s = s + a[i];
    }
    return s;
}


void ReadHeader(){

    char line[2048];
    const string mark = "        X         Y         Z  ";
    const string xDir = "    X direction:   ";
    const string yDir = "    Y direction:   ";
    const string zDir = "    Z direction:   ";

    x.clear();
    y.clear();
    z.clear();

    string temp;
    string temp2;
    stringstream ss;
    float number;
    while(temp.compare(mark) != 0){
        //read header
        infile.getline(line, 2048);

        temp = convertToString(line, xDir.length());
        if(temp.compare(xDir) == 0){
            ss << line;
            for(; !ss.eof(); ss >> temp2){
                if(stringstream(temp2) >> number)
                    x.push_back(number);
            }
        }
        temp = convertToString(line, yDir.length());
        if(temp.compare(yDir) == 0){
            ss.clear();
            ss << line;
            temp2 = "?";
            for(; !ss.eof(); ss >> temp2){
                if(stringstream(temp2) >> number)
                    y.push_back(number);
            }
        }
        temp = convertToString(line, zDir.length());
        if(temp.compare(zDir) == 0){
            ss.clear();
            ss << line;
            temp2 = "?";
            for(; !ss.eof(); ss >> temp2){
                if(stringstream(temp2) >> number)
                    z.push_back(number);
            }
        }

        temp = convertToString(line, MARK_LEN - 1);
    }
}